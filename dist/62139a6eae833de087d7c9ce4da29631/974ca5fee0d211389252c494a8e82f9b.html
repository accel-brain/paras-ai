<!DOCTYPE html> <html lang="ja" style="height: 100%; --font_default: 'Outfit', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; --color_text_default: rgba(27, 27, 27, 1); --color_text_default_rgb: 27,27,27; --color_alert_default: rgba(239, 234, 117, 1); --color_alert_default_rgb: 239,234,117; --color_primary_default: rgba(15, 39, 85, 1); --color_primary_default_rgb: 15,39,85; --color_success_default: rgba(109,213,138,1); --color_success_default_rgb: 109,213,138; --color_surface_default: rgba(240,240,240,1); --color_surface_default_rgb: 240,240,240; --color_background_default: rgba(255, 255, 255, 1); --color_background_default_rgb: 255,255,255; --color_destructive_default: rgba(255,79,79,1); --color_destructive_default_rgb: 255,79,79; --color_primary_contrast_default: rgba(74,63,184,1); --color_primary_contrast_default_rgb: 74,63,184; --color_bTOYR_default: rgba(198,122,245,1); --color_bTOYR_default_rgb: 198,122,245; --color_bTITB0_default: rgba(67,67,67,1); --color_bTITB0_default_rgb: 67,67,67; --color_bTITF0_default: rgba(135,135,135,1); --color_bTITF0_default_rgb: 135,135,135;"> <head> <title>エラーメッセージテスト ――PARAs AI</title>
<style>
       * {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font_default);
            background-color: var(--color_background_default);
            color: var(--color_text_default);
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .content-card {
            background-color: var(--color_surface_default);
            box-shadow: rgba(0, 0, 0, 0.1) 0px 5px 8px 0px;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 20px;
            min-height: 80px;
        }

        .title {
            font-size: 24px;
            font-weight: 700;
            color: var(--color_text_default);
            margin: 0 0 20px 0;
            line-height: 1.4;
        }

        .content-text {
            font-size: 14px;
            font-weight: 400;
            color: var(--color_bTITB0_default);
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .source-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--color_text_default);
            margin: 20px 0 10px 0;
            text-align: left;
        }

        .source-text {
            font-size: 14px;
            font-weight: 400;
            color: var(--color_bTITB0_default);
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .datetime {
            font-size: 14px;
            font-weight: 400;
            color: var(--color_bTITB0_default);
            text-align: right;
            margin-top: 15px;
        }

        .analysis-container {
            background-color: var(--color_background_default);
            border-radius: 20px;
            padding: 28px;
            margin-top: 20px;
        }

        .markdown-body {
            font-family: var(--font_default) !important;
            color: var(--color_text_default) !important;
            background-color: transparent !important;
        }

        .markdown-body h1 {
            color: var(--color_text_default) !important;
            font-weight: 700 !important;
            border-bottom: 2px solid var(--color_primary_contrast_default) !important;
            padding-bottom: 10px !important;
        }

        .markdown-body h2 {
            color: var(--color_text_default) !important;
            font-weight: 600 !important;
        }

        .markdown-body p {
            color: var(--color_bTITB0_default) !important;
        }

        .markdown-body blockquote {
            border-left: 4px solid var(--color_primary_contrast_default) !important;
            background-color: var(--color_surface_default) !important;
            padding: 15px 20px !important;
            margin: 20px 0 !important;
        }

        .copy-button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .copy-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .copy-button:active {
            transform: translateY(0);
        }

        .copy-button.success {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }
        .copy-icon {
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            font-size: 14px;
            margin-left: 8px;
            transition: all 0.3s ease;
            background: rgba(102, 126, 234, 0.1);
            opacity: 0;
            visibility: hidden;
            transform: translateX(10px);
            display: inline-block;
            flex-shrink: 0;
        }

        ul li:hover .copy-icon,
        ul li:focus .copy-icon,
        ul li.show-icon .copy-icon {
            opacity: 0.8;
            visibility: visible;
            transform: translateX(0);
        }

        .copy-icon:hover {
            opacity: 1 !important;
            background: rgba(102, 126, 234, 0.2) !important;
            transform: scale(1.1) !important;
        }

        .copy-icon:active {
            transform: scale(0.9) !important;
        }
        .copy_feedback{
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4CAF50;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateX(100px);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .copy_feedback.show {
            opacity: 1;
            transform: translateX(0);
        }
        .copy_targets {
             opacity: 0;
             width: 0;
             height: 0;
        }
</style>

<script>
async function copyListItem(iconElement) {
    try {
        const listItem = iconElement.parentElement;
        const textSpan = listItem.querySelector('.list-item-text');
        var text = textSpan ? textSpan.textContent.trim() : '';
        if (!text) {
            showFeedback('コピーするテキストが見つかりません', 'error');
            return;
        }
        text = text + " #paras_ai";
        await navigator.clipboard.writeText(text);
        showFeedback('リスト項目をコピーしました！');
        
const originalIcon = iconElement.innerHTML;
const originalWidth = iconElement.offsetWidth; // 元の幅を保存

iconElement.style.color = '#4CAF50';
iconElement.style.background = 'rgba(76, 175, 80, 0.1)';
iconElement.style.width = originalWidth + 'px'; // 幅を固定
iconElement.style.display = 'inline-block'; // インラインブロックにして幅を適用
iconElement.innerHTML = '✅';

setTimeout(() => {
    iconElement.style.color = '';
    iconElement.style.background = 'rgba(102, 126, 234, 0.1)';
    iconElement.style.width = ''; // 幅をリセット
    iconElement.innerHTML = originalIcon;
}, 2500);
        
    } catch (err) {
        console.error('コピーに失敗しました: ', err);
        showFeedback('コピーに失敗しました', 'error');
    }
}
</script>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown.min.css">
    <script>
        // フィードバック表示用の変数
        let feedbackTimeout;

        // 入力フィールドからテキストをコピーする関数
        async function copyToClipboard(elementId, buttonElement) {
            const element = document.getElementById(elementId);
            var text = element.innerHTML;
            text = text + " #paras_ai";
            if (!text.trim()) {
                showFeedback('テキストが入力されていません', 'error');
                return;
            }

            try {
                await navigator.clipboard.writeText(text);
                showFeedback('クリップボードにコピーしました！');
                
                // ボタンの一時的な見た目変更
                if (buttonElement) {
                    const originalText = buttonElement.innerHTML;
                    buttonElement.classList.add('success');
                    buttonElement.innerHTML = '<span class="icon">✅</span>コピー完了！';
                    
                    setTimeout(() => {
                        buttonElement.classList.remove('success');
                        buttonElement.innerHTML = originalText;
                    }, 2000);
                }
                
            } catch (err) {
                console.error('コピーに失敗しました: ', err);
                showFeedback('コピーに失敗しました', 'error');
            }
        }

        // 直接テキストをコピーする関数
        async function copyText(text, buttonElement) {
            try {
                await navigator.clipboard.writeText(text);
                showFeedback('クリップボードにコピーしました！');
                
                // ボタンの一時的な見た目変更
                if (buttonElement) {
                    const originalText = buttonElement.innerHTML;
                    buttonElement.classList.add('success');
                    buttonElement.innerHTML = '<span class="icon">✅</span>完了';
                    
                    setTimeout(() => {
                        buttonElement.classList.remove('success');
                        buttonElement.innerHTML = originalText;
                    }, 2000);
                }
                
            } catch (err) {
                console.error('コピーに失敗しました: ', err);
                showFeedback('コピーに失敗しました', 'error');
            }
        }

        // フィードバック表示関数
        function showFeedback(message, type = 'success') {
            const feedback = document.getElementById('feedback');
            
            // feedback要素が存在しない場合は何もしない
            if (!feedback) {
                console.warn('フィードバック要素が見つかりません');
                return;
            }
            
            // 既存のタイムアウトをクリア
            if (feedbackTimeout) {
                clearTimeout(feedbackTimeout);
            }
            
            // メッセージとスタイルを設定
            if (type === 'error') {
                feedback.style.background = '#f44336';
                feedback.innerHTML = '<span class="icon">❌</span>' + message;
            } else {
                feedback.style.background = '#4CAF50';
                feedback.innerHTML = '<span class="icon">✅</span>' + message;
            }
            
            // フィードバックを表示
            feedback.classList.add('show');
            
            // 3秒後に非表示
            feedbackTimeout = setTimeout(() => {
                feedback.classList.remove('show');
            }, 3000);
        }

        // Clipboard API対応チェック（DOM読み込み後に実行）
        document.addEventListener('DOMContentLoaded', function() {
            if (!navigator.clipboard) {
                showFeedback('お使いのブラウザはクリップボード機能に対応していません', 'error');
            }
        });
    </script></head><body> <div id="copy_feedback" class="copy_feedback">     <span class="icon">✅</span>クリップボードにコピーしました！ </div>  <div class="main-container"><div class="content-card"><h1 class="title">エラーメッセージテスト</h1> <div class="content-text">維新と国民は、与党に協力することで衆院選公約の一部を実現した。少数与党と、案件ごとに野党が協議することはあり得るとしても、水面下の「手柄」争いと制度見直しの乱暴さが目立った。

　国民との合意で、所得税が生じる「年収103万円の壁」を引き上げたものの、保険料が生じる別の「壁」や減収分の財源確保は棚上げした。維新と決めた高校教育の無償化も、費用をどう賄うか詰めていない。税・保険の負担体系、公私教育の役割分担といった長期視点での議論を欠いた。

　立民は、与党が反発を恐れて見送った基礎年金の底上げ策を法案に入れて通した。一定の意義は認められるが、実施の判断は5年後でいいのか。懸念が残る。

　国会審議の空洞化がいわれて久しい中、衆院予算委員会で省庁別審査を導入。党首討論も開催を増やした点は評価できよう。議員同士が国民の前で意見を交えて法案を磨く立法府に向け、通年国会も視野に一層の改革を求めたい。

　今国会での石破氏は、党内基盤の弱さから政権維持へ内向きの姿勢を強め、昨秋の総裁選までの「正論」はすっかり影を潜めた。

　見えぬ首相の指導力

　違法寄付が疑われる新人議員への商品券配布では自ら謝罪に追い込まれ、コメを巡って失言を重ねた江藤拓農相は更迭した。患者の批判を受けた高額療養費の負担増は二転三転の上、全面凍結した。いったん見送った現金給付は急きょ、自民公約に差し入れた。

　一方、大半の野党は公約に消費税の減税・廃止を掲げるが、社会保障の安定財源はどう穴埋めするのか。きのうは「ガソリン減税」実施の法案を衆院で通した。参院は与党が多数で、成立は見通せない。土壇場だけ急に結束を示した点も含め、姿勢が問われよう。

　人口減や地方疲弊に加え、物価高、トランプ米大統領が乱発する高関税策など国民生活を下押しする要因を冷静に見極め、与野党は責任ある公約を示すべきだ。</div> <h2 class="source-title">情報ソース</h2> <div class="source-text">なし</div> <div class="datetime">25/6/21 13:39:40</div> </div>  <div id="score_data"><input type="hidden" value="1" /></div>  <div class="markdown-body" id="paras_generated_text"></div>  <script> if (typeof marked !== 'undefined')  {     html= marked.parse(`

# 概念の定義が曖昧な箇所について

曖昧性が含まれていると思われる箇所は以下の通りです。情報ソースをご入力いただければ、より厳密な判断が可能になります。

- 「年収103万円の壁」という用語の定義が曖昧である。
- 「基礎年金の底上げ策」という用語の定義が曖昧である。

# エビデンスが不十分な箇所について

エビデンスが不十分と思われる箇所は以下の通りです。情報ソースをご入力いただければ、より厳密な判断が可能になります。

- 具体的なデータや根拠を明記するべきであった箇所は、年収103万円の壁の引き上げに留まり、保険料が生じる別の壁や減収分の財源確保は棚上げされた点である。
- 客観的な根拠を明記するべきであった箇所で最も問題なのは、立民が基礎年金の底上げ策を法案に入れて通したという事実が、客観的な根拠を伴って記載されていないことである。
- 具体的な根拠が示されていない。
- 不明瞭な箇所の記載を怠ったことで、読者が正確な情報を得ることができなかった。
- 社会保障の安定財源の穴埋め方法を明記しなかった点は、責任ある公約を示すという点で大きな問題を含む。

# 誤謬について

検出された誤謬は以下の通りです。

## 誤った因果推論

> 懸念が残る。　国会審議の空洞化がいわれて久しい中、衆院予算委員会で省庁別審査を導入。党首討論も開催を増やした点は評価できよう。

- 関係のない事象同士を強引に結びつけること。

# 想定される反対意見

以下のような批評、批判、あるいはアンチコメントが想定されます。

- この記事の論理的整合性が問われる。野党が消費税の減税・廃止を掲げるが、社会保障の安定財源の穴埋め方法が不明確だ。責任ある公約を示すべきだ。
- 情報源が不明確なまま、与党の協力の是非を論じるのは問題。裏付けとなるデータや証拠が不十分で、フェイクニュースの可能性も否定できない。
- 統計データの偽装や操作の可能性を指摘する声は多い。統計の出し方が不適切で、サンプル数や調査方法が書いてないから信用できない。
- 極端な表現や煽動的な内容で、読者を扇動する意図が見え隠れする。感情に訴える表現の多用は、公正中立な報道に反する。
- 根拠のない推測や憶測が、国民の前で意見を交わす立法府の議論を空洞化する。陰謀論的な主張は、政治の混乱を招く。
- 与党が反発を恐れて見送った基礎年金の底上げ策を、立民が法案に含めたのは一定の意義は認めるが、実施の判断は5年後でいいのか。
- この記事の論理的飛躍が目立つ。国会審議の空洞化が指摘される中、省庁別審査を導入した点は評価できるが、税・保険の負担体系や公私教育の役割分担の議論が不十分。
- この記事は、与野党の公約の是非を論じるが、社会保障の安定財源の穴埋め方法や、税・保険の負担体系の議論が不十分だ。
- 立民が法案に含めた基礎年金の底上げ策は、実施の判断が5年後でいいのか。国会審議の空洞化が指摘される中、議論の場を設ける必要がある。
- この記事は、与野党の公約の是非を論じるが、社会保障の安定財源の穴埋め方法や、税・保険の負担体系の議論が不十分だ。
- この記事の問題点は、年収103万円の壁の定義が曖昧な点だ。具体的なデータや根拠が示されていないため、読者が正確な情報を得ることができなかった。責任ある公約を示すためには、明確な定義と根拠を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したとあるが、客観的な根拠を伴って記載されていない。具体的な根拠が示されていないため、信憑性に欠ける。
- この記事は、社会保障の安定財源の穴埋め方法を明記しなかった点を問題視すべきだ。責任ある公約を示すためには、具体的な方法を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したが、実施の判断は5年後でいいのか。具体的な根拠が示されていないため、懸念が残る。
- この記事は、国会審議の空洞化を問題視するが、具体的なデータや根拠が示されていないため、信憑性に欠ける。
- 立民が基礎年金の底上げ策を法案に入れて通したが、具体的な根拠が示されていないため、信憑性に欠ける。
- この記事は、高校教育の無償化の費用をどう賄うか詰めていない点を問題視すべきだ。具体的な方法を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したが、実施の判断は5年後でいいのか。具体的な根拠が示されていないため、懸念が残る。
- この記事は、社会保障の安定財源の穴埋め方法を明記しなかった点を問題視すべきだ。具体的な方法を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したが、具体的な根拠が示されていないため、信憑性に欠ける。
`);     document.getElementById("paras_generated_text").innerHTML = html; } </script>  <div> <div class="copy_targets" id="copy_generated_text">

# 概念の定義が曖昧な箇所について

曖昧性が含まれていると思われる箇所は以下の通りです。情報ソースをご入力いただければ、より厳密な判断が可能になります。

- 「年収103万円の壁」という用語の定義が曖昧である。
- 「基礎年金の底上げ策」という用語の定義が曖昧である。

# エビデンスが不十分な箇所について

エビデンスが不十分と思われる箇所は以下の通りです。情報ソースをご入力いただければ、より厳密な判断が可能になります。

- 具体的なデータや根拠を明記するべきであった箇所は、年収103万円の壁の引き上げに留まり、保険料が生じる別の壁や減収分の財源確保は棚上げされた点である。
- 客観的な根拠を明記するべきであった箇所で最も問題なのは、立民が基礎年金の底上げ策を法案に入れて通したという事実が、客観的な根拠を伴って記載されていないことである。
- 具体的な根拠が示されていない。
- 不明瞭な箇所の記載を怠ったことで、読者が正確な情報を得ることができなかった。
- 社会保障の安定財源の穴埋め方法を明記しなかった点は、責任ある公約を示すという点で大きな問題を含む。

# 誤謬について

検出された誤謬は以下の通りです。

## 誤った因果推論

> 懸念が残る。　国会審議の空洞化がいわれて久しい中、衆院予算委員会で省庁別審査を導入。党首討論も開催を増やした点は評価できよう。

- 関係のない事象同士を強引に結びつけること。

# 想定される反対意見

以下のような批評、批判、あるいはアンチコメントが想定されます。

- この記事の論理的整合性が問われる。野党が消費税の減税・廃止を掲げるが、社会保障の安定財源の穴埋め方法が不明確だ。責任ある公約を示すべきだ。
- 情報源が不明確なまま、与党の協力の是非を論じるのは問題。裏付けとなるデータや証拠が不十分で、フェイクニュースの可能性も否定できない。
- 統計データの偽装や操作の可能性を指摘する声は多い。統計の出し方が不適切で、サンプル数や調査方法が書いてないから信用できない。
- 極端な表現や煽動的な内容で、読者を扇動する意図が見え隠れする。感情に訴える表現の多用は、公正中立な報道に反する。
- 根拠のない推測や憶測が、国民の前で意見を交わす立法府の議論を空洞化する。陰謀論的な主張は、政治の混乱を招く。
- 与党が反発を恐れて見送った基礎年金の底上げ策を、立民が法案に含めたのは一定の意義は認めるが、実施の判断は5年後でいいのか。
- この記事の論理的飛躍が目立つ。国会審議の空洞化が指摘される中、省庁別審査を導入した点は評価できるが、税・保険の負担体系や公私教育の役割分担の議論が不十分。
- この記事は、与野党の公約の是非を論じるが、社会保障の安定財源の穴埋め方法や、税・保険の負担体系の議論が不十分だ。
- 立民が法案に含めた基礎年金の底上げ策は、実施の判断が5年後でいいのか。国会審議の空洞化が指摘される中、議論の場を設ける必要がある。
- この記事は、与野党の公約の是非を論じるが、社会保障の安定財源の穴埋め方法や、税・保険の負担体系の議論が不十分だ。
- この記事の問題点は、年収103万円の壁の定義が曖昧な点だ。具体的なデータや根拠が示されていないため、読者が正確な情報を得ることができなかった。責任ある公約を示すためには、明確な定義と根拠を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したとあるが、客観的な根拠を伴って記載されていない。具体的な根拠が示されていないため、信憑性に欠ける。
- この記事は、社会保障の安定財源の穴埋め方法を明記しなかった点を問題視すべきだ。責任ある公約を示すためには、具体的な方法を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したが、実施の判断は5年後でいいのか。具体的な根拠が示されていないため、懸念が残る。
- この記事は、国会審議の空洞化を問題視するが、具体的なデータや根拠が示されていないため、信憑性に欠ける。
- 立民が基礎年金の底上げ策を法案に入れて通したが、具体的な根拠が示されていないため、信憑性に欠ける。
- この記事は、高校教育の無償化の費用をどう賄うか詰めていない点を問題視すべきだ。具体的な方法を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したが、実施の判断は5年後でいいのか。具体的な根拠が示されていないため、懸念が残る。
- この記事は、社会保障の安定財源の穴埋め方法を明記しなかった点を問題視すべきだ。具体的な方法を明記する必要がある。
- 立民が基礎年金の底上げ策を法案に入れて通したが、具体的な根拠が示されていないため、信憑性に欠ける。
</div> <button class="copy-button" onclick="copyToClipboard('copy_generated_text', this)">     <span class="icon">📋</span>コピーする </button> </div> </body><script>


function generateCommentsDesign() {
    // <h1>想定される反対意見</h1>を検索し、未処理のもののみを対象とする
    const headings = document.querySelectorAll('h1');
    const targetUls = [];
    
    for (let heading of headings) {
        if (heading.textContent.trim() === '想定される反対意見') {
            // 次のul要素を検索
            let nextElement = heading.nextElementSibling;
            while (nextElement) {
                if (nextElement.tagName === 'UL') {
                    // 既に処理済みかチェック
                    if (!nextElement.classList.contains('opposition-comments-processed')) {
                        targetUls.push(nextElement);
                    }
                    break;
                }
                nextElement = nextElement.nextElementSibling;
            }
        }
    }
    
    if (targetUls.length === 0) {
        console.log('新規で対象となるul要素が見つかりません（既に処理済みの可能性があります）');
        return;
    }
    
    // Font Awesomeのスタイルシートを追加（まだ読み込まれていない場合）
    if (!document.querySelector('link[href*="font-awesome"]')) {
        const fontAwesomeLink = document.createElement('link');
        fontAwesomeLink.rel = 'stylesheet';
        fontAwesomeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';
        document.head.appendChild(fontAwesomeLink);
        
        // Font Awesomeの読み込み完了を待つ
        fontAwesomeLink.onload = function() {
            applyStylesToElements();
        };
    } else {
        applyStylesToElements();
    }
    
    function applyStylesToElements() {
        // 怒り、嫌悪感、批判、非難を表すFont Awesomeアイコンの配列（CSS Classes方式）
        const negativeIconClasses = [
            'fas fa-angry',      // 怒った顔
            'fas fa-frown',      // しかめっ面
            'fas fa-dizzy',      // めまい/困惑した顔
            'fas fa-meh-blank',  // 無表情
            'fas fa-meh',        // 普通の顔（批判的文脈）
            'fas fa-tired',      // 疲れた顔
            'fas fa-grimace',    // しかめ顔
            'fas fa-sad-tear',   // 悲しい涙
            'fas fa-frown-open', // 口を開けてしかめっ面
            'fas fa-angry'       // 追加の怒り顔
        ];
        
        // ネガティブな感情を表す色の配列
        const negativeColors = [
            '#e74c3c', // 赤
            '#c0392b', // 暗い赤
            '#e67e22', // オレンジ
            '#d35400', // 暗いオレンジ
            '#f39c12', // 黄色がかったオレンジ
            '#8e44ad', // 紫
            '#9b59b6', // 薄い紫
            '#34495e', // 暗いグレー
            '#2c3e50', // さらに暗いグレー
            '#7f8c8d', // グレー
            '#ad4e00', // ダークオレンジ
            '#a93226', // ダークレッド
            '#6c3483', // ダークパープル
            '#2874a6', // ダークブルー
            '#138d75'  // ダークティール
        ];
        
        // 対象のul要素すべてにユニークなIDを追加し、スタイルを適用
        const styleRules = [];
        
        targetUls.forEach((targetUl, index) => {
            const uniqueId = 'opposition-ul-' + Date.now() + '-' + index;
            targetUl.id = uniqueId;
            
            // 処理済みのマークを追加
            targetUl.classList.add('opposition-comments-processed');
            
            // 各ul要素用のスタイル定義を追加
            styleRules.push(`
                #${uniqueId} {
                    background-color: #f8f9fa;
                    border: 1px solid #e1e5e9;
                    border-radius: 8px;
                    padding: 16px;
                    margin: 16px 0;
                    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
                    list-style: none;
                }
                
                #${uniqueId} li {
                    background-color: #ffffff;
                    border: 1px solid #e1e5e9;
                    border-radius: 6px;
                    margin-bottom: 12px;
                    padding: 16px 16px 16px 56px;
                    position: relative;
                    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                    line-height: 1.6;
                    font-size: 14px;
                    color: #333;
                    list-style: none;
                    display: flex;
                    align-items: center;
                }
                
                #${uniqueId} li:last-child {
                    margin-bottom: 0;
                }
                
                #${uniqueId} li .comment-icon {
                    position: absolute;
                    left: 16px;
                    top: 50%;
                    transform: translateY(-50%);
                    font-size: 18px;
                    background-color: #ffffff;
                    border-radius: 50%;
                    width: 32px;
                    height: 32px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                    border: 2px solid #e1e5e9;
                    transition: transform 0.2s ease;
                }
                
                #${uniqueId} li:hover {
                    background-color: #f8f9fa;
                    border-color: #d1d5db;
                }
                
                #${uniqueId} li:hover .comment-icon {
                    transform: translateY(-50%) scale(1.1);
                }
                
                #${uniqueId} li .comment-text {
                    flex: 1;
                    margin-left: 0;
                }
            `);
        });
        
        // ヤフーニュースコメント風のスタイルを追加
        const style = document.createElement('style');
        style.textContent = styleRules.join('\
');
        document.head.appendChild(style);
        
        // 各ul要素の各li要素を処理
        let totalProcessed = 0;
        targetUls.forEach(targetUl => {
            const listItems = targetUl.querySelectorAll('li');
            listItems.forEach((li, index) => {
                // 既に処理済みかチェック
                if (li.classList.contains('opposition-li-processed')) {
                    return; // 処理済みの場合はスキップ
                }
                
                // ランダムにアイコンクラスを選択
                const randomIconClass = negativeIconClasses[Math.floor(Math.random() * negativeIconClasses.length)];
                // ランダムに色を選択
                const randomColor = negativeColors[Math.floor(Math.random() * negativeColors.length)];
                
                // 元のテキストコンテンツを保存
                const originalText = li.textContent || li.innerText;
                
                // li要素の内容をクリアして再構築
                li.innerHTML = '';
                
                // アイコン要素を作成
                const iconElement = document.createElement('i');
                iconElement.className = `${randomIconClass} comment-icon`;
                iconElement.style.color = randomColor;
                
                // テキスト要素を作成
                const textElement = document.createElement('span');
                textElement.className = 'comment-text';
                textElement.textContent = originalText;
                
                // コピー機能が既に設定されている場合は保持
                const existingCopyIcon = li.querySelector('.copy-icon');
                if (existingCopyIcon) {
                    // 既存のコピー機能を保持
                    const copyIcon = existingCopyIcon.cloneNode(true);
                    textElement.appendChild(copyIcon);
                }
                
                // li要素に新しい構造を追加
                li.appendChild(iconElement);
                li.appendChild(textElement);
                
                // 処理済みのマークを追加
                li.classList.add('opposition-li-processed');
                
                // アニメーション効果を追加
                setTimeout(() => {
                    iconElement.style.opacity = '0';
                    iconElement.style.transform = 'translateY(-50%) scale(0.5)';
                    
                    setTimeout(() => {
                        iconElement.style.transition = 'all 0.3s ease';
                        iconElement.style.opacity = '1';
                        iconElement.style.transform = 'translateY(-50%) scale(1)';
                    }, 50);
                }, index * 100); // 順次表示効果
                
                totalProcessed++;
            });
        });
        
        console.log(`${targetUls.length}個の新規「想定される反対意見」セクションで、合計${totalProcessed}個の反対意見をヤフーニュースコメント風にスタイリングしました（CSS Classes方式使用）`);
    }
}

// コピー機能との連携を強化する関数
function enhanceCopyFunctionality() {
    // 既存のコピー機能がある場合、新しい構造に対応させる
    const copyItems = document.querySelectorAll('.opposition-comments-processed li');
    
    copyItems.forEach(item => {
        const textSpan = item.querySelector('.comment-text');
        const copyIcon = item.querySelector('.copy-icon');
        
        if (textSpan && copyIcon && !item.hasAttribute('data-copy-enhanced')) {
            // コピー機能を新しい構造に適応
            item.addEventListener('click', function(e) {
                if (e.target.classList.contains('copy-icon')) {
                    const textContent = textSpan.textContent.replace(/📋/g, '').trim();
                    copyListItem(e.target, textContent);
                }
            });
            
            item.setAttribute('data-copy-enhanced', 'true');
        }
    });
}

// アイコンの色を動的に変更する関数（ホバー効果強化）
function addHoverEffects() {
    const commentIcons = document.querySelectorAll('.comment-icon');
    
    commentIcons.forEach(icon => {
        const originalColor = icon.style.color;
        
        icon.addEventListener('mouseenter', function() {
            // ホバー時に色を少し明るくする
            const rgb = hexToRgb(originalColor);
            if (rgb) {
                const lighterColor = `rgb(${Math.min(255, rgb.r + 30)}, ${Math.min(255, rgb.g + 30)}, ${Math.min(255, rgb.b + 30)})`;
                this.style.color = lighterColor;
            }
        });
        
        icon.addEventListener('mouseleave', function() {
            // ホバー終了時に元の色に戻す
            this.style.color = originalColor;
        });
    });
}

// 16進数カラーをRGBに変換するヘルパー関数
function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

// メイン実行
generateCommentsDesign();

</script>

<script>
function addCopyFuncToParasList(){    
    // ページ内のすべてのli要素を取得
    const listItems = document.querySelectorAll('#paras_generated_text li');
    
    listItems.forEach(function(item, index) {
        // 既に処理済みかチェック
        if (item.querySelector('.list-item-text')) {
            return;
        }
                
        // 元のテキストを保存
        const originalText = item.textContent.trim();
        
        // 空の要素はスキップ
        if (!originalText) {
            return;
        }
        
        // tabindex属性を動的に追加（キーボードナビゲーション用）
        item.setAttribute('tabindex', '0');
        
        // 新しい構造を作成
        item.innerHTML = '';
        
        // テキスト部分
        const textSpan = document.createElement('span');
        textSpan.className = 'list-item-text';
        textSpan.textContent = originalText;
        
        // コピーアイコン
        const iconSpan = document.createElement('span');
        iconSpan.className = 'copy-icon';
        iconSpan.innerHTML = '📋';
        iconSpan.addEventListener('click', function() {
            copyListItem(this);
        });
        
        // 要素を追加
        item.appendChild(textSpan);
        item.appendChild(iconSpan);
        
        // ホバーイベント
        item.addEventListener('mouseenter', function() {
            this.classList.add('show-icon');
        });
        
        item.addEventListener('mouseleave', function() {
            this.classList.remove('show-icon');
        });
        
        // フォーカスイベント
        item.addEventListener('focus', function() {
            this.classList.add('show-icon');
            
            setTimeout(() => {
                if (this === document.activeElement) {
                    this.blur();
                }
            }, 3000);
        });
        
        item.addEventListener('blur', function() {
            this.classList.remove('show-icon');
        });
        
        // キーボードイベント
        item.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                copyListItem(iconSpan);
            }
        });
        
        console.log('Item', index + 1, 'setup complete');
    });
    
    console.log('All list items setup complete');
    
    // Clipboard API チェック
    if (!navigator.clipboard) {
        showFeedback('お使いのブラウザはクリップボード機能に対応していません', 'error');
    }
}
addCopyFuncToParasList();
</script></html>